"""
MTSET_call
=============

Description
-----------
This module provides an interface to interact with the MTSET executable from Python. 
It creates a subprocess for the MSET executable, loads in the input file walls.xxx, 
and writes the output to the tdat.xxx data file for use within MTSOL. 

Classes
-------
MSET_call
    A class to handle the interface between Python and the MSET executable.

Examples
--------
>>> analysisName = "test_case"
>>> test = MTSET_call("test_case")
>>> execute_MTSET = test.caller()

Notes
-----
This module is designed to work with the MTSET executable. Ensure that the executable and the input file, walls.xxx, 
are present in the same directory as this Python file. When executing the file as a standalone, it uses the inputs 
and calls contained within the if __name__ == "__main__" section. This part also imports the time module to measure 
the time needed to perform each file generation call. This is beneficial in runtime optimization.

References
----------
The required input data, limitations, and structures are documented within the MTFLOW user manual:
https://web.mit.edu/drela/Public/web/mtflow/mtflow.pdf

Versioning
------
Author: T.S. Vermeulen
Email: T.S.Vermeulen@student.tudelft.nl
Student ID: 4995309
Version: 1.0

Changelog:
- V0.5: Initial working version. Keeps fixed grid resolution as generated by MTSET without refining. Grid refining to be added in final version. 
- V0.6: Updated documentation & type hinting. Removed dummy inputs & streamlined execution. 
- V0.7: Now uses streamline-bunching towards the stagnation streamlines, and updated streamline and streamwise point spacing/counts. 
- V1.0: Implemented waiting loop until statefile has been generated. Class now automatically deletes statefile if it already existed at start of execution. Added stdinwrite function to clean up writing to subprocess
"""

import subprocess
import os
import time

class MTSET_call:
    """
    Class to handle the interface between MTSET and Python
    """

    def __init__(self, 
                 analysis_name: str,
                 grid_e_coeff: float = None,
                 grid_x_coeff: float = None,
                 streamwise_points: int = None,
                 ) -> None:
        """
        Initialize the MTSET_call class with the analysis name.

        Parameters
        ----------
        - analysis_name : str
            The name of the analysis case.
        - grid_e_coeff : float, optional
            The E coefficient for the exponent of airfoil side points within MTSET. If None, uses the default MTSET value of 0.8. 
        - grid_x_coeff : float, optional
            The X spacing parameter within MTSET. Larger values yield a more rectangular grid. If None, uses the default MTSET value of 0.8.
        - streamwise_points : int, optional
            The number of streamwise points. If None, uses the default MTSET value of 141. 
        """

        self.analysis_name = analysis_name

        # Grid definition parameters need to either take the user-defined input or the default inputs
        self.grid_e_coeff = grid_e_coeff if grid_e_coeff is not None else 0.8
        self.grid_x_coeff = grid_x_coeff if grid_x_coeff is not None else 0.8
        self.streamwise_points = streamwise_points if (streamwise_points is not None and streamwise_points > 141) else 200

        # Define constant filepath for the MTSET executable 
        self.process_path: str = os.getenv('MTSET_PATH', 'mtset.exe')
        if not os.path.exists(self.process_path):
            raise FileNotFoundError(f"MTSET executable not found at {self.process_path}")
        
        # Define filepath for the statefile
        self.fpath = 'tdat.{}'.format(self.analysis_name)
    

    def StdinWrite(self,
                   command: str) -> None:
        """
        Simple function to write commands to the subprocess stdin in order to pass commands to MTSET.

        Parameters
        ----------
        - command : str
            The text-based command to pass to MTSET

        Returns
        -------
        None
        """

        self.process.stdin.write(f"{command} \n")
        self.process.stdin.flush()


    def GenerateProcess(self, 
                        ) -> None:
        """
        Create MTSET subprocess

        Simple function to create an MTSET subprocress using the defined
        executable path and analysis name in the class initialization. 
        The defined subprocess has the inputs, outputs, and error file 
        handles sent to PIPE for direct interaction within the Python code.  
        """

        # Get the directory where the current Python file is located
        current_file_directory = os.path.dirname(os.path.abspath(__file__))

        # Change the working directory to the directory of the current Python file
        os.chdir(current_file_directory)

        # Generate subprocess
        self.process = subprocess.Popen([self.process_path, self.analysis_name], 
                                 stdin=subprocess.PIPE, 
                                 stdout=subprocess.PIPE, 
                                 stderr=subprocess.PIPE,
                                 shell=True, 
                                 text=True,
                                 bufsize=1,
                                 )
        
        # Check if subprocess is started successfully
        if self.process.poll() is not None:
            raise ImportError(f"MTSET or walls.{self.analysis_name} not found in {self.process_path}") from None
    

    def WaitForMainMenu(self) -> list[str]:
        """
        Wait for MTSET to return to the main menu.

        Returns
        -------
        None
        """

        interface_output = []
        while True:
            next_line = self.process.stdout.readline()  # Collect output and add to list
            interface_output.append(next_line)                
            if next_line == "" and self.process.poll() is not None:  #Handle (unexpected) quitting of program
               break
            if next_line == '   Q uit\n':  # Stop collecting once end of MTSET menu is reached
               break
        
        return interface_output
        

    def GridGenerator(self, 
                      ) -> None:
        """
        Automatic grid generator and grid refinement

        Function to handle the loading of the axisymmetric bodies and 
        generation of an initial numerical grid.

        As a limit, the walls.xxx file is expected to have at least 1 body, but no upper limit. 
        In practice, there will be 2 bodies (duct and center body).
        """
        
        # Load the walls.xxx file and count number of elements to be loaded
        # The second(+) elements are preceded by line containing [999. 999.], 
        # which can be used to count the number of elements to be loaded in by MTSET
        element_count = 1  # There is a minimum of 1 element present
        with open(r'walls.' + self.analysis_name, 'r') as file: 
            for index, line in enumerate(file): 
                if index < 2:  # Skip the first two lines (0 and 1) - these contain the analysis name and grid size. 
                    continue 
                numbers = map(float, line.split()) 
                element_count += sum(1 for num in numbers if num == 999.) // 2  # New element identifier contains 2x 999., so divide the count by 2

        #Accept the default spacing ratios for each of the elements loaded in
        for _ in range(element_count):
            self.StdinWrite("")  # Send return command to MTSET

        # Exit grid spacing definition routine
        self.StdinWrite("\n")

        # Wait for MTSET to be in the main menu before modifying the grid
        self.WaitForMainMenu()

        # Enter grid modification menu and set grid parameters
        self.StdinWrite("m")

        # Enable streamline bunching towards stagnation lines for better resolution of near-element flowfield
        self.StdinWrite("j 1")

        # Use increased number of streamlines for increased resolution
        self.StdinWrite("s 45")

        # Set exponent for number of airfoil side points. The number of point is then equal to e * N
        self.StdinWrite(f"e {self.grid_e_coeff}")

        # Set x spacing factor. Lower values yield a more "rounded" grid
        self.StdinWrite(f"x {self.grid_x_coeff}")

        # Set the number of streamwise points 
        self.StdinWrite(f"n {self.streamwise_points}")

        # Change the streamline spacing to decrease the spacing at the centerbody
        self.StdinWrite("w1 0.7")
        self.StdinWrite("w2 0.3")
        self.StdinWrite("t1 0.05")

        # Toggle quasi-normal lines fixed in x (This is only used when there is no duct, i.e. an open rotor/propeller. 
        # When there is a duct present, this option is disabled, so the input has no effect)
        self.StdinWrite("Q")
        
        # Exit grid modification menu
        self.StdinWrite("") 

        #Accept the default spacing ratios for each of the elements loaded in
        for _ in range(element_count):
            self.StdinWrite("")

        # Exit grid spacing definition routine
        self.StdinWrite("")
    

    def GridSmoothing(self, 
                      ) -> None:
        """
        Elliptic grid smoothing function
        
        Performs elliptic grid smoothing on the created grid until converged. 
        Convergence is measured by checking the last pass in the smoothing process 
        for the presence of Dmax in the terminal output. 
        If Dmax is no longer present within the grid, set smoothing to false 
        and exit the routine.
        """

        # Control smoothing process, including detection when further smoothing is no longer needed
        while True:
            self.StdinWrite("e")  # Execute elliptic smoothing continue command
            
            # Collect console output from MTSET, stopping when the end of the menu is reached
            interface_output = self.WaitForMainMenu()
            
            # Find the index of 'Pass 10' (i.e. the final pass of the smoothing process). Checks from the back of the list
            pass_10_index = next((i for i, s in reversed(list(enumerate(interface_output))) if 'Pass          10' in s), -1)

            if "Dmax" not in interface_output[pass_10_index + 1]: #Check the row following Pass 10 to see if smoothing is converged
                break


    def FileGenerator(self, 
                      ) -> None:
        """
        Generation of required files and outputs from MTSET to use in 
        further analyses

        This is a very simple function to handle the end-of-procedure steps in MTSET, generating the output file.
        This output files can then be used in later analyses. 

        tdat.xxx is a (binary) solution storage file, containing an incompressible, 
        inviscid flow solution as starting point for the MTFLO field parameter specification or MTSOL solver. 
        This file is created using a standard, built-in function within MTSET.
        """

        # Create tdat.xxx file
        # Note that MTSET automatically closes after writing the tdat file!
        self.StdinWrite("w")

        # Check that MTSET has closed successfully 
        if self.process.poll() is not None:
            try:
                self.process.wait(timeout=5)
            
            except subprocess.TimeoutExpired:
                self.process.kill()
                raise OSError("MTSET did not close after file generation. Process was killed.") from None


    def caller(self,
               ) -> None:
        """
        Full interfacing function between Python and MTSET

        Requires that the input file, walls.xxx, has been made and is available.

        Returns
        -------
        None
        """

        # Delete the tdat file, if it already existed. 
        os.unlink(self.fpath) if os.path.exists(self.fpath) else None 
        
        # Create subprocess for the MTSET tool
        self.GenerateProcess()  

        # Initialize the numerical grid
        self.GridGenerator()

        # Perform elliptical grid smoothing
        self.GridSmoothing()  

        # Generate files 
        self.FileGenerator()   

        # Check that the tdat file writing was successful
        while not os.path.exists(self.fpath):
            time.sleep(0.01)  # Wait for the file to be created

        
if __name__ == "__main__":
    start_time = time.time()
    analysisName = "test_case"
    test = MTSET_call(analysisName)
    execute_MTSET = test.caller()
    end_time = time.time()

    print(f"Execution of MTSET_call({analysisName}).caller() took {end_time - start_time} seconds")