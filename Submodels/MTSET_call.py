"""
MTSET_call
=============

Description
-----------
This module provides an interface to interact with the MTSET executable from Python. 
It creates a subprocess for the MSET executable, loads in the input file walls.xxx, 
and writes the output to the tdat.xxx data file for use within MTSOL. 

Classes
-------
MSET_call
    A class to handle the interface between Python and the MSET executable.

Examples
--------
>>> filepath = r"mtset.exe"
>>> analysisName = "test_case"
>>> test = MTSET_call(r'mtset.exe', "test_case")
>>> execute_MTSET = test.caller()

Notes
-----
This module is designed to work with the MTSET executable. Ensure that the executable and the input file, walls.xxx, 
are present in the same directory as this Python file. When executing the file as a standalone, it uses the inputs 
and calls contained within the if __name__ == "__main__" section. This part also imports the time module to measure 
the time needed to perform each file generation call. This is beneficial in runtime optimization.

References
----------
The required input data, limitations, and structures are documented within the MTFLOW user manual:
https://web.mit.edu/drela/Public/web/mtflow/mtflow.pdf

Versioning
------
Author: T.S. Vermeulen
Email: T.S.Vermeulen@student.tudelft.nl
Student ID: 4995309
Version: 0.7

Changelog:
- V0.5: Initial working version. Keeps fixed grid resolution as generated by MTSET without refining. Grid refining to be added in final version. 
- V0.6: Updated documentation & type hinting. Removed dummy inputs & streamlined execution. 
- V0.7: Now uses streamline-bunching towards the stagnation streamlines, and updated streamline and streamwise point spacing/counts. 
"""

import subprocess
import os

class MTSET_call:
    """
    Class to handle the interface between MTSET and Python
    """

    def __init__(self, 
                 analysis_name: str,
                 grid_e_coeff: float = None,
                 grid_x_coeff: float = None,
                 ) -> None:
        """
        Initialize the MTSET_call class with the analysis name.

        Parameters
        ----------
        - analysis_name : str
            The name of the analysis case.
        - grid_e_coeff : float, optional
            The E coefficient for the exponent of airfoil side points within MTSET. If None, uses the default MTSET value of 0.8. 
        - grid_x_coeff : float, optional
            The X spacing parameter within MTSET. Larger values yield a more rectangular grid. If None, uses the default MTSET value of 0.8.
        """

        self.analysis_name = analysis_name

        # Grid definition parameters need to either take the user-defined input or the default MTSET inputs
        if grid_e_coeff is None: 
            self.grid_e_coeff = 0.8
        else:
            self.grid_e_coeff = grid_e_coeff

        if grid_x_coeff is None:
            self.grid_x_coeff = 0.8
        else:
            self.grid_x_coeff = grid_x_coeff

        # Define constant filepath 
        self.fpath: str = r"mtset.exe"

    def GenerateProcess(self, 
                        ) -> None:
        """
        Create MTSET subprocess

        Simple function to create an MTSET subprocress using the defined
        executable path and analysis name in the class initialization. 
        The defined subprocess has the inputs, outputs, and error file 
        handles sent to PIPE for direct interaction within the Python code.  
        """

        # Get the directory where the current Python file is located
        current_file_directory = os.path.dirname(os.path.abspath(__file__))

        # Change the working directory to the directory of the current Python file
        os.chdir(current_file_directory)

        # Generate subprocess
        self.process = subprocess.Popen([self.fpath, self.analysis_name], 
                                 stdin=subprocess.PIPE, 
                                 stdout=subprocess.PIPE, 
                                 stderr=subprocess.PIPE,
                                 shell=True, 
                                 text=True,
                                 bufsize=1,
                                 )
        
        # Check if subprocess is started successfully
        if self.process.poll() is not None:
            raise ImportError(f"MTSET or walls.{self.analysis_name} not found in {self.fpath}") from None
    

    def GridGenerator(self, 
                      ) -> None:
        """
        Automatic grid generator and grid refinement

        Function to handle the loading of the axisymmetric bodies and 
        generation of an initial numerical grid.

        As a limit, the walls.xxx file is expected to have at least 1 body, but no upper limit. 
        In practice, there will be 2 bodies (duct and center body).
        """
        
        # Load the walls.xxx file and count number of elements to be loaded
        # The second(+) elements are preceded by line containing [999. 999.], 
        # which can be used to count the number of elements to be loaded in by MTSET
        element_count = 1  # There is a minimum of 1 element present
        with open(r'walls.' + self.analysis_name, 'r') as file: 
            for index, line in enumerate(file): 
                if index < 2:  # Skip the first two lines (0 and 1) - these contain the analysis name and grid size. 
                    continue 
                numbers = map(float, line.split()) 
                element_count += sum(1 for num in numbers if num == 999.) // 2  # New element identifier contains 2x 999., so divide the count by 2

        #Accept the default spacing ratios for each of the elements loaded in
        for _ in range(element_count):
            self.process.stdin.write("\n")
            self.process.stdin.flush()  # Send return command to MTSET

        # Exit grid spacing definition routine
        self.process.stdin.write("\n")
        self.process.stdin.flush()

        # Enter grid modification menu and set grid parameters
        self.process.stdin.write("m\n")

        # Enable streamline bunching towards stagnation lines for better resolution of near-element flowfield
        self.process.stdin.write("j 1\n")

        # Use increased number of streamlines for increased resolution
        self.process.stdin.write("s 45\n")

        # Set exponent for number of airfoil side points. The number of point is then equal to e * N
        self.process.stdin.write(f"e {self.grid_e_coeff} \n")

        # Set x spacing factor. Lower values yield a more "rounded" grid
        self.process.stdin.write(f"x {self.grid_x_coeff} \n") 

        # Set the number of streamwise points to 200 rather than the default 141 for increased resolution
        self.process.stdin.write("n 200\n")

        # Toggle quasi-normal lines fixed in x (This is only used when there is no duct, i.e. an open rotor/propeller. 
        # When there is a duct present, this option is disabled, so the input has no effect)
        self.process.stdin.write("Q \n")
        
        # Exit grid modification menu
        self.process.stdin.write("\n")  

        #Accept the default spacing ratios for each of the elements loaded in
        for _ in range(element_count):
            self.process.stdin.write("\n")
            self.process.stdin.flush()  # Send return command to MTSET

        # Exit grid spacing definition routine
        self.process.stdin.write("\n")
        self.process.stdin.flush()  # Send commands to MTSET
    

    def GridSmoothing(self, 
                      ) -> None:
        """
        Elliptic grid smoothing function
        
        Performs elliptic grid smoothing on the created grid until converged. 
        Convergence is measured by checking the last pass in the smoothing process 
        for the presence of Dmax in the terminal output. 
        If Dmax is no longer present within the grid, set smoothing to false 
        and exit the routine.
        """

        # Control smoothing process, including detection when further smoothing is no longer needed
        while True:
            self.process.stdin.write("e\n")  # Execute elliptic smoothing continue command
            self.process.stdin.flush()  # Send command to MTSET
            
            # Collect console output from MTSET, stopping when the end of the menu is reached
            interface_output = []
            while True:
                next_line = self.process.stdout.readline()  # Collect output and add to list
                interface_output.append(next_line)
                
                if next_line == "" and self.process.poll() is not None:  #Handle (unexpected) quitting of program
                    break
                if next_line == '   Q uit\n':  # Stop collecting once end of MTSET menu is reached
                    break
            
            # Find the index of 'Pass 10' (i.e. the final pass of the smoothing process). Checks from the back of the list
            pass_10_index = next((i for i, s in reversed(list(enumerate(interface_output))) if 'Pass          10' in s), -1)

            if "Dmax" not in interface_output[pass_10_index + 1]: #Check the row following Pass 10 to see if smoothing is converged
                break


    def FileGenerator(self, 
                      ) -> None:
        """
        Generation of required files and outputs from MTSET to use in 
        further analyses

        This is a very simple function to handle the end-of-procedure steps in MTSET, generating the output file.
        This output files can then be used in later analyses. 

        tdat.xxx is a (binary) solution storage file, containing an incompressible, 
        inviscid flow solution as starting point for the MTFLO field parameter specification or MTSOL solver. 
        This file is created using a standard, built-in function within MTSET.
        """

        # Create tdat.xxx file
        # Note that MTSET automatically closes after writing the tdat file!
        self.process.stdin.write("w\n")

        # Check that MTSET has closed successfully 
        if self.process.poll() is not None:
            try:
                self.process.wait(timeout=5)
            
            except subprocess.TimeoutExpired:
                self.process.kill()
                raise OSError("MTSET did not close after file generation. Process was killed.") from None
        else:    
            return 


    def caller(self,
               ) -> None:
        """
        Full interfacing function between Python and MTSET

        Requires that the input file, walls.xxx, has been made and is available.

        Returns
        -------
        - self.process.returncode : int
            The returncode of the finished subprocess.
        """
        
        # Create subprocess for the MTSET tool
        self.GenerateProcess()  

        # Initialize the numerical grid
        self.GridGenerator()

        # Perform elliptical grid smoothing
        self.GridSmoothing()  

        # Generate files 
        self.FileGenerator()   

        return      

        
if __name__ == "__main__":


    import time
    start_time = time.time()
    analysisName = "test_case"
    test = MTSET_call(analysisName)
    execute_MTSET = test.caller()
    end_time = time.time()

    print(f"Execution of MTSET_call({analysisName}).caller() took {end_time - start_time} seconds")