"""

MTSET calling class definition. 

The class definition contains all the required functions to interface the MTSET code with Python. 

@author: T.S.Vermeulen
@email: thomas0708.vermeulen@gmail.com / T.S.Vermeulen@student.tudelft.nl
@version: 0.5

Changelog:
- V0.5: Initial working version. Keeps fixed grid resolution as generated by MTSET without refining. Grid refining to be added in final version. 

"""

import subprocess
import os

class MTSET_call:


    def __init__(self, *args):
        filePath, analysisName = args
        self.fPath = filePath
        self.analysisName = analysisName

        return None


    def GenerateProcess(self, 
                        dummy: None
                        ):
        """
        -----
        Create MTSET subprocess
        -----

        Simple function to create an MTSET subprocress using the defined
        executable path and analysis name in the class initialization. 
        The defined subprocess has the inputs, outputs, and error file 
        handles sent to PIPE for direct interaction within the Python code.  
        """

        self.process = subprocess.Popen([self.fPath, self.analysisName], 
                                 stdin=subprocess.PIPE, 
                                 stdout=subprocess.PIPE, 
                                 stderr=subprocess.PIPE,
                                 shell=True, 
                                 text=True
                                 )
        return self
    

    def GridGenerator(self, 
                      dummy: None
                      ):
        """
        -----
        Automatic grid generator and grid refinement
        -----

        Function to handle the loading of the axisymmetric bodies and 
        generation of an initial numerical grid.

        As a limit, the walls.xxx file is expected to have at least 1 body, but no upper limit. 
        In practice, there will be 2 bodies (duct and center body).

        # -----
        # TO DO 
        # include handling of updated spacing;
        # get current number of streamwise gridpoints
        # automatically refine grid
        # -----
        """
        
        # First step is to load in the walls.xxx file to check the number of axisymmetric bodies
        # Get the directory where the current Python file is located
        current_file_directory = os.path.dirname(os.path.abspath(__file__))

        # Change the working directory to the directory of the current Python file
        os.chdir(current_file_directory)

        # Load the walls.xxx file and count number of elements to be loaded
        # The second(+) elements are preceded by line containing [999. 999.], 
        # which can be used to count the number of elements to be loaded in by MTSET
        element_count = 1  # There is a minimum of 1 element present
        with open(r'walls.' + self.analysisName, 'r') as file: 
            for index, line in enumerate(file): 
                if index < 2:  # Skip the first two lines (0 and 1) - these contain the analysis name and grid size. 
                    continue 
                numbers = map(float, line.split()) 
                element_count += int(sum(1 for num in numbers if num == 999.)/2)  # New element identifier contains2 2x 999., so divide the count by 2

        #Accept the default spacing ratios for each of the elements loaded in
        for i in range(element_count):
            self.process.stdin.write("\n")
            self.process.stdin.flush()  # Send return command to MTSET

        # Exit grid spacing definition routine
        self.process.stdin.write("\n")
        self.process.stdin.flush()

        # -----
        # TO DO 
        # include handling of updated spacing;
        # get current number of streamwise gridpoints
        # automatically refine grid
        # -----
        return self
    

    def GridSmoothing(self, 
                      dummy: None
                      ):
        """
        -----
        Elliptic grid smoothing function
        -----
        
        Performs elliptic grid smoothing on the created grid until converged. 
        Convergence is measured by checking the last pass in the smoothing process 
        for the presence of Dmax in the terminal output. 
        If Dmax is no longer present within the grid, set smoothing to false 
        and exit the routine.
        """

        # Define controlling booleans for the smoothing process
        smoothing = True
        get_console_out = True

        # Control smoothing process, including detection when further smoothing is no longer needed
        while smoothing:
            self.process.stdin.write("e\n")  # Execute elliptic smoothing continue command
            self.process.stdin.flush()  # Send command to MTSET
            
            # Collect console output from MTSET, stopping when the end of the menu is reached
            interface_output = []
            while get_console_out:
                next_line = self.process.stdout.readline()  # Collect output and add to list
                interface_output.append(next_line)
                
                if next_line == "" and self.process.poll() is not None:  #Handle (unexpected) quitting of program
                    break
                if next_line == '   Q uit\n':  # Stop collecting once end of MTSET menu is reached
                    break
            
            # Find the index of 'Pass 10' (i.e. the final pass of the smoothing process). Checks from the back of the list
            pass_10_index = next((i for i, s in reversed(list(enumerate(interface_output))) if 'Pass          10' in s), -1)

            if "Dmax" not in interface_output[pass_10_index + 1]: #Check the row following Pass 10 to see if smoothing is converged
                break
        return self


    def FileGenerator(self, 
                      dummy: None, 
                      ):
        """
        -----
        Generation of required files and outputs from MTSET to use in 
        further analyses
        -----

        This is a very simple function to handle the end-of-procedure steps in MTSET, generating the output file.
        This output files can then be used in later analyses. 

        tdat.xxx is a (binary) solution storage file, containing an incompressible, 
        inviscid flow solution as starting point for the MTFLO field parameter specification or MTSOL solver. 
        This file ise created using a standard, built-in function within MTSET.
        """

        # Create tdat.xxx file
        # Note that MTSET automatically closes after writing the tdat file!
        self.process.stdin.write("w\n")

        # Check that MTSET has closed successfully 
        if self.process.poll() is not None:
            try:
                self.process.wait(timeout=1)
            except subprocess.TimeoutExpired:
                self.process.kill()
                raise OSError("Something went wrong in the MTSET call. \
                            MTSET was not closed following end of file generation. \
                            Run terminated.")
        else:    
            return self


    def caller(self
               ):
        """
        -----
        Full interfacing function between Python and MTSET
        -----

        Requires that the input file, walls.xxx, has been made and is available.
        """
        
        # Create subprocess for the MTSET tool
        self.GenerateProcess(self)  

        # Initialize the numerical grid
        self.GridGenerator(self)

        # Perform elliptical grid smoothing
        self.GridSmoothing(self)  

        # Generate files 
        self.FileGenerator(self)   

        return self.process.returncode         

        

if __name__ == "__main__":
    test = MTSET_call(r'mtset.exe', "dprop")

    execute_MTSET = test.caller()
    
    